#!/usr/bin/env bash

set -eu -o pipefail

# ------------------------------------------------------------------------------
# Globals
# ------------------------------------------------------------------------------
MIN_DELAY="0.0001"
MAX_DELAY="0.0005"
SCALE=${#MIN_DELAY}

TYPO_CHARS="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789,.'\":;-"
TYPO_PROBABILITY=${TYPO_PROBABILITY:-50}  # chance in 10,000 of a typo occurring

# ------------------------------------------------------------------------------
# Keyboard distances
# ------------------------------------------------------------------------------
declare -A keyboard_layout

# Row 0
keyboard_layout[\`]="0,0"
keyboard_layout[1]="0,1"
keyboard_layout[2]="0,2"
keyboard_layout[3]="0,3"
keyboard_layout[4]="0,4"
keyboard_layout[5]="0,5"
keyboard_layout[6]="0,6"
keyboard_layout[7]="0,7"
keyboard_layout[8]="0,8"
keyboard_layout[9]="0,9"
keyboard_layout[0]="0,10"
keyboard_layout['-']="0,11"
keyboard_layout['=']="0,12"

# Row 1
keyboard_layout[q]="1,0"
keyboard_layout[w]="1,1"
keyboard_layout[e]="1,2"
keyboard_layout[r]="1,3"
keyboard_layout[t]="1,4"
keyboard_layout[y]="1,5"
keyboard_layout[u]="1,6"
keyboard_layout[i]="1,7"
keyboard_layout[o]="1,8"
keyboard_layout[p]="1,9"
keyboard_layout['[']="1,10"
keyboard_layout[']']="1,11"
keyboard_layout["\\"]="1,12"

# Row 2
keyboard_layout[a]="2,0"
keyboard_layout[s]="2,1"
keyboard_layout[d]="2,2"
keyboard_layout[f]="2,3"
keyboard_layout[g]="2,4"
keyboard_layout[h]="2,5"
keyboard_layout[j]="2,6"
keyboard_layout[k]="2,7"
keyboard_layout[l]="2,8"
keyboard_layout[';']="2,9"
keyboard_layout["'"]="2,10"

# Row 3
keyboard_layout[z]="3,0"
keyboard_layout[x]="3,1"
keyboard_layout[c]="3,2"
keyboard_layout[v]="3,3"
keyboard_layout[b]="3,4"
keyboard_layout[n]="3,5"
keyboard_layout[m]="3,6"
keyboard_layout[',']="3,7"
keyboard_layout['.']="3,8"
keyboard_layout['/']="3,9"

# Space bar (assuming it's roughly below 'v','b','n','m')
keyboard_layout[' ']="3,5"

# Memoize key distances
declare -A distances

calculate_distance() {
  local x1 y1 x2 y2 distance

  if [[ -n "${distances[$1 - $2]-}" ]]; then
    echo "${distances[$1 - $2]}"
    return
  fi

  if [[ -n "${keyboard_layout[$1]-}" ]]; then
    IFS=',' read -r y1 x1 <<<"${keyboard_layout[$1]}"
  else
    x1=5.5
    y1=2
  fi

  if [[ -n "${keyboard_layout[$2]-}" ]]; then
    IFS=',' read -r y2 x2 <<<"${keyboard_layout[$2]}"
  else
    x2=5.5
    y2=2
  fi

  distance=$(awk -v x1="$x1" -v y1="$y1" -v x2="$x2" -v y2="$y2" \
             'BEGIN {print sqrt((x2-x1)^2 + (y2-y1)^2)}')

  distances[$1 - $2]="$distance"

  echo "$distance"
}

# ------------------------------------------------------------------------------
# General functions
# ------------------------------------------------------------------------------
usage() {
  local exit_code="${1:-0}"

  cat <<EOL
usage: type [OPTIONS]

Options:
  --help | -h  show help information
  --slow | -s  type slower
  --fast | -f  type faster

EOL

  exit "$exit_code"
}

pause() {
  local min="${1:-$MIN_DELAY}"
  local max="${2:-$MAX_DELAY}"

  rand=$(echo "($max - $min) * 100" | bc | awk '{printf "%d", $1}')

  # Ensure rand is never zero
  [[ "$rand" -eq 0 ]] && rand=1

  sleep "$(echo "scale=$SCALE; $min + ( $RANDOM % $rand ) / 100" | bc)"
}

typo() {
  local typo_occur
  local num_chars
  local typo
  local i

  # Randomly decide if a typo should occur
  typo_occur=$((RANDOM % 10000 < TYPO_PROBABILITY))

  if [[ "$typo_occur" -eq 1 ]]; then
    num_chars=$(((RANDOM % 4) + 1))

    for ((i = 0; i < num_chars; i++)); do
      typo=$(echo -n "$TYPO_CHARS" | fold -w1 | shuf -n1)
      printf "%s" "$typo"
      pause
    done

    # Short pause while the typist notices the error
    pause 0.25 1

    # Then delete it
    for ((i = 0; i < num_chars; i++)); do
      printf "\b \b"
      pause
    done
  fi
}

# ------------------------------------------------------------------------------
# Process arguments
# ------------------------------------------------------------------------------
while (("$#")); do
  case "$1" in
    --help | -h)
      usage 0
      ;;

    --slow | w)
      MIN_DELAY=$(echo "scale=$SCALE; $MIN_DELAY * 3" | bc)
      MAX_DELAY=$(echo "scale=$SCALE; $MAX_DELAY * 3" | bc)
      shift
      ;;

    --fast | -f)
      MIN_DELAY=$(echo "scale=$SCALE; $MIN_DELAY / 3" | bc)
      MAX_DELAY=$(echo "scale=$SCALE; $MAX_DELAY / 3" | bc)
      shift
      ;;

    *) ;;
  esac
done

# ------------------------------------------------------------------------------
# "Type" out the input from STDIN
# ------------------------------------------------------------------------------
last_char=""

while IFS= read -r LINE; do
  in_escape_seq=false

  for ((i = 0; i < ${#LINE}; i++)); do
    # Collect the correct character
    char="${LINE:$i:1}"

    # Check if entering an ANSI escape sequence
    if [[ "$char" == $'\033' ]]; then
      in_escape_seq=true
    fi

    # Possibly make a typo
    if [[ "$in_escape_seq" == false ]]; then
      typo
    fi

    # Now type the correct character
    printf "%s" "$char"

    # Check if leaving an ANSI escape sequence
    if [[ "$in_escape_seq" == true && "$char" == "m" ]]; then
      in_escape_seq=false
      continue
    fi

    # Sleep only for printable characters outside of escape sequences
    if [[ "$in_escape_seq" == false && "$char" =~ [[:print:]] ]]; then
      dist="1"

      if [ -n "$last_char" ]; then
        dist=$(calculate_distance "$last_char" "$char")
      fi

      last_char="$char"

      min=$(echo "scale=$SCALE; $MIN_DELAY * $dist" | bc -l)
      max=$MAX_DELAY

      pause "$min" "$max"
    fi
  done

  echo
done
